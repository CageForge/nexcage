const std = @import("std");
const types = @import("types");
const Layer = @import("layer.zig").Layer;
const LayerError = @import("layer.zig").LayerError;

pub const LayerFSError = error{
    InvalidMountPoint,
    InvalidLayerPath,
    LayerNotFound,
    MountFailed,
    UnmountFailed,
    ReadOnlyFilesystem,
    WriteFailed,
    InvalidOverlay,
    ZFSError,
    PathError,
    PermissionDenied,
    InvalidLayerOrder,
    CircularDependency,
    StorageError,
    CompressionError,
    DecompressionError,
    ValidationError,
    MetadataError,
};

/// LayerFS provides a filesystem abstraction for managing OCI image layers
pub const LayerFS = struct {
    allocator: std.mem.Allocator,
    base_path: []const u8,
    layers: std.StringHashMap(*Layer),
    mount_points: std.StringHashMap([]const u8),
    overlay_mounts: std.StringHashMap([]const u8),
    readonly: bool,
    
    const Self = @This();
    
    /// Initialize a new LayerFS instance
    pub fn init(allocator: std.mem.Allocator, base_path: []const u8) !*Self {
        const layerfs = try allocator.create(Self);
        layerfs.* = .{
            .allocator = allocator,
            .base_path = try allocator.dupe(u8, base_path),
            .layers = std.StringHashMap(*Layer).init(allocator),
            .mount_points = std.StringHashMap([]const u8).init(allocator),
            .overlay_mounts = std.StringHashMap([]const u8).init(allocator),
            .readonly = false,
        };
        
        return layerfs;
    }
    
    /// Clean up LayerFS resources
    pub fn deinit(self: *Self) void {
        // Unmount all overlay mounts
        var it = self.overlay_mounts.iterator();
        while (it.next()) |entry| {
            _ = self.unmountOverlay(entry.key_ptr.*);
            // Don't free entry.value_ptr.* as it's managed by unmountOverlay
        }
        self.overlay_mounts.deinit();
        
        // Free mount points
        var mp_it = self.mount_points.iterator();
        while (mp_it.next()) |entry| {
            self.allocator.free(entry.key_ptr.*);
            self.allocator.free(entry.value_ptr.*);
        }
        self.mount_points.deinit();
        
        // Free layer digests (but don't deinit layers as they're owned elsewhere)
        var layer_it = self.layers.iterator();
        while (layer_it.next()) |entry| {
            self.allocator.free(entry.key_ptr.*);
        }
        self.layers.deinit();
        
        // Free base path
        self.allocator.free(self.base_path);
        
        // Free self
        self.allocator.destroy(self);
    }
    
    /// Add a layer to the filesystem
    pub fn addLayer(self: *Self, layer: *Layer) !void {
        if (self.layers.contains(layer.digest)) {
            return LayerFSError.LayerNotFound;
        }
        
        const digest_copy = try self.allocator.dupe(u8, layer.digest);
        try self.layers.put(digest_copy, layer);
    }
    
    /// Get a layer by digest
    pub fn getLayer(self: *Self, digest: []const u8) ?*Layer {
        return self.layers.get(digest);
    }
    
    /// Remove a layer from the filesystem
    pub fn removeLayer(self: *Self, digest: []const u8) !void {
        if (self.layers.fetchRemove(digest)) |entry| {
            self.allocator.free(entry.key);
        }
    }
    
    /// Create a mount point for a layer
    pub fn createMountPoint(self: *Self, layer_digest: []const u8, mount_path: []const u8) !void {
        _ = self.getLayer(layer_digest) orelse return LayerFSError.LayerNotFound;
        
        if (self.mount_points.contains(layer_digest)) {
            return LayerFSError.InvalidMountPoint;
        }
        
        // Duplicate strings to ensure ownership
        const digest_copy = try self.allocator.dupe(u8, layer_digest);
        const path_copy = try self.allocator.dupe(u8, mount_path);
        
        try self.mount_points.put(digest_copy, path_copy);
    }
    
    /// Get mount point for a layer
    pub fn getMountPoint(self: *Self, layer_digest: []const u8) ?[]const u8 {
        return self.mount_points.get(layer_digest);
    }
    
    /// Mount a layer as an overlay filesystem
    pub fn mountOverlay(self: *Self, layer_digest: []const u8, mount_path: []const u8) !void {
        _ = self.getLayer(layer_digest) orelse return LayerFSError.LayerNotFound;
        
        if (self.overlay_mounts.contains(layer_digest)) {
            return LayerFSError.InvalidOverlay;
        }
        
        // Create mount directory if it doesn't exist
        try std.fs.cwd().makePath(mount_path);
        
        // For now, we'll simulate overlay mounting
        // In a real implementation, this would use mount(2) with overlayfs
        // Duplicate strings to ensure ownership
        const digest_copy = try self.allocator.dupe(u8, layer_digest);
        const path_copy = try self.allocator.dupe(u8, mount_path);
        
        try self.overlay_mounts.put(digest_copy, path_copy);
    }
    
    /// Unmount an overlay filesystem
    pub fn unmountOverlay(self: *Self, layer_digest: []const u8) void {
        if (self.overlay_mounts.fetchRemove(layer_digest)) |entry| {
            self.allocator.free(entry.key);
            self.allocator.free(entry.value);
        }
    }
    
    /// Get all layers in dependency order
    pub fn getLayersInOrder(self: *Self) ![]*Layer {
        var ordered_layers = std.ArrayList(*Layer).init(self.allocator);
        defer ordered_layers.deinit();
        
        var visited = std.StringHashMap(bool).init(self.allocator);
        defer {
            var it = visited.iterator();
            while (it.next()) |entry| {
                self.allocator.free(entry.key_ptr.*);
            }
            visited.deinit();
        };
        
        var it = self.layers.iterator();
        while (it.next()) |entry| {
            try self.dfsVisit(entry.value_ptr.*, &visited, &ordered_layers);
        }
        
        return ordered_layers.toOwnedSlice();
    }
    
    /// Depth-first search for dependency ordering
    fn dfsVisit(
        self: *Self,
        layer: *Layer,
        visited: *std.StringHashMap(bool),
        ordered: *std.ArrayList(*Layer),
    ) !void {
        if (visited.contains(layer.digest)) {
            return;
        }
        
        // Mark as visited to detect cycles
        const digest_copy = try self.allocator.dupe(u8, layer.digest);
        try visited.put(digest_copy, true);
        
        // Visit dependencies first
        if (layer.dependencies) |deps| {
            for (deps) |dep_digest| {
                if (self.getLayer(dep_digest)) |dep_layer| {
                    try self.dfsVisit(dep_layer, visited, ordered);
                }
            }
        }
        
        // Add this layer after its dependencies
        try ordered.append(layer);
    }
    
    /// Validate all layers in the filesystem
    pub fn validateAllLayers(self: *Self) !void {
        var it = self.layers.iterator();
        while (it.next()) |entry| {
            try entry.value_ptr.*.validate(self.allocator);
        }
    }
    
    /// Check for circular dependencies
    pub fn checkCircularDependencies(self: *Self) !void {
        var visited = std.StringHashMap(bool).init(self.allocator);
        defer {
            // Free all keys in visited
            var it = visited.iterator();
            while (it.next()) |entry| {
                self.allocator.free(entry.key_ptr.*);
            }
            visited.deinit();
        };
        
        var rec_stack = std.StringHashMap(bool).init(self.allocator);
        defer {
            // Free all keys in rec_stack
            var it = rec_stack.iterator();
            while (it.next()) |entry| {
                self.allocator.free(entry.key_ptr.*);
            }
            rec_stack.deinit();
        };
        
        var it = self.layers.iterator();
        while (it.next()) |entry| {
            if (try self.hasCycle(entry.value_ptr.*, &visited, &rec_stack)) {
                return LayerFSError.CircularDependency;
            }
        }
    }
    
    /// Check if a layer has a cycle in its dependency graph
    fn hasCycle(
        self: *Self,
        layer: *Layer,
        visited: *std.StringHashMap(bool),
        rec_stack: *std.StringHashMap(bool),
    ) !bool {
        if (rec_stack.contains(layer.digest)) {
            return true; // Back edge found
        }
        
        if (visited.contains(layer.digest)) {
            return false; // Already processed
        }
        
        // Mark as visited and in recursion stack
        const digest_copy1 = try self.allocator.dupe(u8, layer.digest);
        const digest_copy2 = try self.allocator.dupe(u8, layer.digest);
        try visited.put(digest_copy1, true);
        try rec_stack.put(digest_copy2, true);
        
        // Check dependencies
        if (layer.dependencies) |deps| {
            for (deps) |dep_digest| {
                if (self.getLayer(dep_digest)) |dep_layer| {
                    if (try self.hasCycle(dep_layer, visited, rec_stack)) {
                        return true;
                    }
                }
            }
        }
        
        // Remove from recursion stack
        _ = rec_stack.remove(layer.digest);
        
        return false;
    }
    
    /// Get filesystem statistics
    pub fn getStats(self: *Self) !LayerFSStats {
        var total_size: u64 = 0;
        var total_layers: u32 = 0;
        var mounted_layers: u32 = 0;
        
        var it = self.layers.iterator();
        while (it.next()) |entry| {
            total_size += entry.value_ptr.*.size;
            total_layers += 1;
            
            if (self.overlay_mounts.contains(entry.key_ptr.*)) {
                mounted_layers += 1;
            }
        }
        
        return LayerFSStats{
            .total_layers = total_layers,
            .mounted_layers = mounted_layers,
            .total_size = total_size,
            .base_path = try self.allocator.dupe(u8, self.base_path),
        };
    }
    
    /// Set filesystem as read-only
    pub fn setReadOnly(self: *Self, readonly: bool) void {
        self.readonly = readonly;
    }
    
    /// Check if filesystem is read-only
    pub fn isReadOnly(self: *Self) bool {
        return self.readonly;
    }
};

/// Statistics for LayerFS
pub const LayerFSStats = struct {
    total_layers: u32,
    mounted_layers: u32,
    total_size: u64,
    base_path: []const u8,
    
    pub fn deinit(self: *LayerFSStats, allocator: std.mem.Allocator) void {
        allocator.free(self.base_path);
    }
};

/// Create a new LayerFS instance
pub fn createLayerFS(allocator: std.mem.Allocator, base_path: []const u8) !*LayerFS {
    return LayerFS.init(allocator, base_path);
}

/// Initialize a LayerFS instance
pub fn initLayerFS(allocator: std.mem.Allocator, base_path: []const u8) !*LayerFS {
    return LayerFS.init(allocator, base_path);
}
